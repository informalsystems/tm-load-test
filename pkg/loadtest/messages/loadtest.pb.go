// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: loadtest.proto

package messages

import (
	fmt "fmt"
	actor "github.com/AsynkronIT/protoactor-go/actor"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// SlaveReady is sent by a slave when it's ready to start load testing.
type SlaveReady struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *SlaveReady) Reset()      { *m = SlaveReady{} }
func (*SlaveReady) ProtoMessage() {}
func (*SlaveReady) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{0}
}
func (m *SlaveReady) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveReady) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveReady.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveReady) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveReady.Merge(m, src)
}
func (m *SlaveReady) XXX_Size() int {
	return m.Size()
}
func (m *SlaveReady) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveReady.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveReady proto.InternalMessageInfo

func (m *SlaveReady) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// SlaveAccepted is sent by the master to a slave to indicate that it's been
// accepted for load testing.
type SlaveAccepted struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *SlaveAccepted) Reset()      { *m = SlaveAccepted{} }
func (*SlaveAccepted) ProtoMessage() {}
func (*SlaveAccepted) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{1}
}
func (m *SlaveAccepted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveAccepted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveAccepted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveAccepted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveAccepted.Merge(m, src)
}
func (m *SlaveAccepted) XXX_Size() int {
	return m.Size()
}
func (m *SlaveAccepted) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveAccepted.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveAccepted proto.InternalMessageInfo

func (m *SlaveAccepted) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// SlaveRejected is sent by the master to a slave when it already has too many
// connected slaves, or it has seen a slave with the same ID before.
type SlaveRejected struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=Reason,proto3" json:"Reason,omitempty"`
}

func (m *SlaveRejected) Reset()      { *m = SlaveRejected{} }
func (*SlaveRejected) ProtoMessage() {}
func (*SlaveRejected) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{2}
}
func (m *SlaveRejected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveRejected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveRejected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveRejected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveRejected.Merge(m, src)
}
func (m *SlaveRejected) XXX_Size() int {
	return m.Size()
}
func (m *SlaveRejected) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveRejected.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveRejected proto.InternalMessageInfo

func (m *SlaveRejected) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *SlaveRejected) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// StartLoadTest is sent by the master to the slaves to kick off the testing.
type StartLoadTest struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *StartLoadTest) Reset()      { *m = StartLoadTest{} }
func (*StartLoadTest) ProtoMessage() {}
func (*StartLoadTest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{3}
}
func (m *StartLoadTest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartLoadTest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartLoadTest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartLoadTest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartLoadTest.Merge(m, src)
}
func (m *StartLoadTest) XXX_Size() int {
	return m.Size()
}
func (m *StartLoadTest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartLoadTest.DiscardUnknown(m)
}

var xxx_messageInfo_StartLoadTest proto.InternalMessageInfo

func (m *StartLoadTest) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// LoadTestUnderway is sent by slaves on a regular basis from the instant that
// load testing starts. This acts as a notification to the master that the
// slaves are, in fact, testing, as well as a form of health check/heartbeat to
// ensure that the load testing completes effectively.
type LoadTestUnderway struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *LoadTestUnderway) Reset()      { *m = LoadTestUnderway{} }
func (*LoadTestUnderway) ProtoMessage() {}
func (*LoadTestUnderway) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{4}
}
func (m *LoadTestUnderway) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadTestUnderway) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadTestUnderway.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadTestUnderway) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadTestUnderway.Merge(m, src)
}
func (m *LoadTestUnderway) XXX_Size() int {
	return m.Size()
}
func (m *LoadTestUnderway) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadTestUnderway.DiscardUnknown(m)
}

var xxx_messageInfo_LoadTestUnderway proto.InternalMessageInfo

func (m *LoadTestUnderway) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// MasterFailed is sent by the master node to the slaves if the master node
// encounters an error from which it cannot recover.
type MasterFailed struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=Reason,proto3" json:"Reason,omitempty"`
}

func (m *MasterFailed) Reset()      { *m = MasterFailed{} }
func (*MasterFailed) ProtoMessage() {}
func (*MasterFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{5}
}
func (m *MasterFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MasterFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MasterFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MasterFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MasterFailed.Merge(m, src)
}
func (m *MasterFailed) XXX_Size() int {
	return m.Size()
}
func (m *MasterFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_MasterFailed.DiscardUnknown(m)
}

var xxx_messageInfo_MasterFailed proto.InternalMessageInfo

func (m *MasterFailed) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MasterFailed) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// SlaveFailed is sent by a slave if testing fails for any reason.
type SlaveFailed struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=Reason,proto3" json:"Reason,omitempty"`
}

func (m *SlaveFailed) Reset()      { *m = SlaveFailed{} }
func (*SlaveFailed) ProtoMessage() {}
func (*SlaveFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{6}
}
func (m *SlaveFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveFailed.Merge(m, src)
}
func (m *SlaveFailed) XXX_Size() int {
	return m.Size()
}
func (m *SlaveFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveFailed.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveFailed proto.InternalMessageInfo

func (m *SlaveFailed) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *SlaveFailed) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// SlaveUpdate is an intermediate update message from a slave to the master
// during load testing.
type SlaveUpdate struct {
	Sender           *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	InteractionCount int64      `protobuf:"varint,2,opt,name=InteractionCount,proto3" json:"InteractionCount,omitempty"`
}

func (m *SlaveUpdate) Reset()      { *m = SlaveUpdate{} }
func (*SlaveUpdate) ProtoMessage() {}
func (*SlaveUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{7}
}
func (m *SlaveUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveUpdate.Merge(m, src)
}
func (m *SlaveUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SlaveUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveUpdate proto.InternalMessageInfo

func (m *SlaveUpdate) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *SlaveUpdate) GetInteractionCount() int64 {
	if m != nil {
		return m.InteractionCount
	}
	return 0
}

// SlaveFinished is sent by a slave when it successfully finishes its load
// testing.
type SlaveFinished struct {
	Sender *actor.PID     `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
	Stats  *CombinedStats `protobuf:"bytes,2,opt,name=Stats,proto3" json:"Stats,omitempty"`
}

func (m *SlaveFinished) Reset()      { *m = SlaveFinished{} }
func (*SlaveFinished) ProtoMessage() {}
func (*SlaveFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{8}
}
func (m *SlaveFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlaveFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlaveFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlaveFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlaveFinished.Merge(m, src)
}
func (m *SlaveFinished) XXX_Size() int {
	return m.Size()
}
func (m *SlaveFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_SlaveFinished.DiscardUnknown(m)
}

var xxx_messageInfo_SlaveFinished proto.InternalMessageInfo

func (m *SlaveFinished) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *SlaveFinished) GetStats() *CombinedStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CheckAllSlavesConnected is sent by the master to itself after a preconfigured
// timeout period to ensure that all slaves are connected. If we are missing
// slaves at this time, the master will fail and shut down.
type CheckAllSlavesConnected struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *CheckAllSlavesConnected) Reset()      { *m = CheckAllSlavesConnected{} }
func (*CheckAllSlavesConnected) ProtoMessage() {}
func (*CheckAllSlavesConnected) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{9}
}
func (m *CheckAllSlavesConnected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckAllSlavesConnected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckAllSlavesConnected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckAllSlavesConnected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAllSlavesConnected.Merge(m, src)
}
func (m *CheckAllSlavesConnected) XXX_Size() int {
	return m.Size()
}
func (m *CheckAllSlavesConnected) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAllSlavesConnected.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAllSlavesConnected proto.InternalMessageInfo

func (m *CheckAllSlavesConnected) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// Kill is an internal message for terminating a node when SIGTERM or SIGINT is
// received.
type Kill struct {
	Sender *actor.PID `protobuf:"bytes,1,opt,name=Sender,proto3" json:"Sender,omitempty"`
}

func (m *Kill) Reset()      { *m = Kill{} }
func (*Kill) ProtoMessage() {}
func (*Kill) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{10}
}
func (m *Kill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Kill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Kill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Kill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kill.Merge(m, src)
}
func (m *Kill) XXX_Size() int {
	return m.Size()
}
func (m *Kill) XXX_DiscardUnknown() {
	xxx_messageInfo_Kill.DiscardUnknown(m)
}

var xxx_messageInfo_Kill proto.InternalMessageInfo

func (m *Kill) GetSender() *actor.PID {
	if m != nil {
		return m.Sender
	}
	return nil
}

// CombinedStats encapsulates the statistics we receive from a slave node
// during/after testing for both interactions and requests.
type CombinedStats struct {
	TotalTestTime int64                    `protobuf:"varint,1,opt,name=TotalTestTime,proto3" json:"TotalTestTime,omitempty"`
	Interactions  *SummaryStats            `protobuf:"bytes,2,opt,name=Interactions,proto3" json:"Interactions,omitempty"`
	Requests      map[string]*SummaryStats `protobuf:"bytes,3,rep,name=Requests,proto3" json:"Requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CombinedStats) Reset()      { *m = CombinedStats{} }
func (*CombinedStats) ProtoMessage() {}
func (*CombinedStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{11}
}
func (m *CombinedStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CombinedStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CombinedStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CombinedStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CombinedStats.Merge(m, src)
}
func (m *CombinedStats) XXX_Size() int {
	return m.Size()
}
func (m *CombinedStats) XXX_DiscardUnknown() {
	xxx_messageInfo_CombinedStats.DiscardUnknown(m)
}

var xxx_messageInfo_CombinedStats proto.InternalMessageInfo

func (m *CombinedStats) GetTotalTestTime() int64 {
	if m != nil {
		return m.TotalTestTime
	}
	return 0
}

func (m *CombinedStats) GetInteractions() *SummaryStats {
	if m != nil {
		return m.Interactions
	}
	return nil
}

func (m *CombinedStats) GetRequests() map[string]*SummaryStats {
	if m != nil {
		return m.Requests
	}
	return nil
}

// SummaryStats is a collection of statistics across a number of interactions or
// requests.
type SummaryStats struct {
	Count        int64 `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	Errors       int64 `protobuf:"varint,2,opt,name=Errors,proto3" json:"Errors,omitempty"`
	TotalTime    int64 `protobuf:"varint,3,opt,name=TotalTime,proto3" json:"TotalTime,omitempty"`
	MinTime      int64 `protobuf:"varint,4,opt,name=MinTime,proto3" json:"MinTime,omitempty"`
	MaxTime      int64 `protobuf:"varint,5,opt,name=MaxTime,proto3" json:"MaxTime,omitempty"`
	TotalClients int64 `protobuf:"varint,6,opt,name=TotalClients,proto3" json:"TotalClients,omitempty"`
	// For keeping track of the different kinds of errors that occurred, as well
	// as the number of times each error occurred.
	ErrorsByType map[string]int64 `protobuf:"bytes,7,rep,name=ErrorsByType,proto3" json:"ErrorsByType,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Allows us to plot a summary picture of the range of response times during
	// our interactions/requests.
	ResponseTimes *ResponseTimeHistogram `protobuf:"bytes,8,opt,name=ResponseTimes,proto3" json:"ResponseTimes,omitempty"`
}

func (m *SummaryStats) Reset()      { *m = SummaryStats{} }
func (*SummaryStats) ProtoMessage() {}
func (*SummaryStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{12}
}
func (m *SummaryStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SummaryStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SummaryStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SummaryStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SummaryStats.Merge(m, src)
}
func (m *SummaryStats) XXX_Size() int {
	return m.Size()
}
func (m *SummaryStats) XXX_DiscardUnknown() {
	xxx_messageInfo_SummaryStats.DiscardUnknown(m)
}

var xxx_messageInfo_SummaryStats proto.InternalMessageInfo

func (m *SummaryStats) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SummaryStats) GetErrors() int64 {
	if m != nil {
		return m.Errors
	}
	return 0
}

func (m *SummaryStats) GetTotalTime() int64 {
	if m != nil {
		return m.TotalTime
	}
	return 0
}

func (m *SummaryStats) GetMinTime() int64 {
	if m != nil {
		return m.MinTime
	}
	return 0
}

func (m *SummaryStats) GetMaxTime() int64 {
	if m != nil {
		return m.MaxTime
	}
	return 0
}

func (m *SummaryStats) GetTotalClients() int64 {
	if m != nil {
		return m.TotalClients
	}
	return 0
}

func (m *SummaryStats) GetErrorsByType() map[string]int64 {
	if m != nil {
		return m.ErrorsByType
	}
	return nil
}

func (m *SummaryStats) GetResponseTimes() *ResponseTimeHistogram {
	if m != nil {
		return m.ResponseTimes
	}
	return nil
}

// ResponseTimeHistogram allows us to plot the range of different
// interaction/response times during a particular load test.
type ResponseTimeHistogram struct {
	Timeout  int64           `protobuf:"varint,1,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	BinSize  int64           `protobuf:"varint,2,opt,name=BinSize,proto3" json:"BinSize,omitempty"`
	BinCount int64           `protobuf:"varint,3,opt,name=BinCount,proto3" json:"BinCount,omitempty"`
	TimeBins map[int64]int64 `protobuf:"bytes,4,rep,name=TimeBins,proto3" json:"TimeBins,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *ResponseTimeHistogram) Reset()      { *m = ResponseTimeHistogram{} }
func (*ResponseTimeHistogram) ProtoMessage() {}
func (*ResponseTimeHistogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_cbef85f58fc0bd9a, []int{13}
}
func (m *ResponseTimeHistogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseTimeHistogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseTimeHistogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseTimeHistogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseTimeHistogram.Merge(m, src)
}
func (m *ResponseTimeHistogram) XXX_Size() int {
	return m.Size()
}
func (m *ResponseTimeHistogram) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseTimeHistogram.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseTimeHistogram proto.InternalMessageInfo

func (m *ResponseTimeHistogram) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *ResponseTimeHistogram) GetBinSize() int64 {
	if m != nil {
		return m.BinSize
	}
	return 0
}

func (m *ResponseTimeHistogram) GetBinCount() int64 {
	if m != nil {
		return m.BinCount
	}
	return 0
}

func (m *ResponseTimeHistogram) GetTimeBins() map[int64]int64 {
	if m != nil {
		return m.TimeBins
	}
	return nil
}

func init() {
	proto.RegisterType((*SlaveReady)(nil), "messages.SlaveReady")
	proto.RegisterType((*SlaveAccepted)(nil), "messages.SlaveAccepted")
	proto.RegisterType((*SlaveRejected)(nil), "messages.SlaveRejected")
	proto.RegisterType((*StartLoadTest)(nil), "messages.StartLoadTest")
	proto.RegisterType((*LoadTestUnderway)(nil), "messages.LoadTestUnderway")
	proto.RegisterType((*MasterFailed)(nil), "messages.MasterFailed")
	proto.RegisterType((*SlaveFailed)(nil), "messages.SlaveFailed")
	proto.RegisterType((*SlaveUpdate)(nil), "messages.SlaveUpdate")
	proto.RegisterType((*SlaveFinished)(nil), "messages.SlaveFinished")
	proto.RegisterType((*CheckAllSlavesConnected)(nil), "messages.CheckAllSlavesConnected")
	proto.RegisterType((*Kill)(nil), "messages.Kill")
	proto.RegisterType((*CombinedStats)(nil), "messages.CombinedStats")
	proto.RegisterMapType((map[string]*SummaryStats)(nil), "messages.CombinedStats.RequestsEntry")
	proto.RegisterType((*SummaryStats)(nil), "messages.SummaryStats")
	proto.RegisterMapType((map[string]int64)(nil), "messages.SummaryStats.ErrorsByTypeEntry")
	proto.RegisterType((*ResponseTimeHistogram)(nil), "messages.ResponseTimeHistogram")
	proto.RegisterMapType((map[int64]int64)(nil), "messages.ResponseTimeHistogram.TimeBinsEntry")
}

func init() { proto.RegisterFile("loadtest.proto", fileDescriptor_cbef85f58fc0bd9a) }

var fileDescriptor_cbef85f58fc0bd9a = []byte{
	// 716 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x41, 0x4f, 0xdb, 0x4a,
	0x10, 0x8e, 0x31, 0x09, 0x61, 0x92, 0x3c, 0xf1, 0x56, 0x3c, 0xb0, 0xa2, 0x27, 0x3f, 0x64, 0xbd,
	0x4a, 0x11, 0x2a, 0xa6, 0x82, 0x0a, 0x55, 0x54, 0x55, 0x95, 0xa4, 0xa0, 0xa6, 0x80, 0x54, 0x39,
	0xe1, 0xd8, 0xc3, 0x26, 0x59, 0x85, 0x2d, 0xce, 0x6e, 0xea, 0xdd, 0xd0, 0xba, 0xa7, 0x1e, 0xdb,
	0x5b, 0x7f, 0x46, 0x7f, 0x4a, 0x8f, 0x1c, 0x39, 0x16, 0x73, 0xe9, 0xad, 0xfc, 0x84, 0xca, 0x6b,
	0x1b, 0x6c, 0x41, 0x85, 0xa5, 0xf6, 0xe6, 0x99, 0x6f, 0xbe, 0x6f, 0x67, 0xbe, 0x99, 0x28, 0xf0,
	0x97, 0xcb, 0xf1, 0x50, 0x12, 0x21, 0xed, 0x89, 0xc7, 0x25, 0x47, 0xe5, 0x31, 0x11, 0x02, 0x8f,
	0x88, 0xa8, 0x6f, 0x8d, 0xa8, 0x3c, 0x9a, 0xf6, 0xed, 0x01, 0x1f, 0xaf, 0x37, 0x85, 0xcf, 0x8e,
	0x3d, 0xce, 0x3a, 0xbd, 0x75, 0x55, 0x86, 0x07, 0x92, 0x7b, 0x6b, 0x23, 0xbe, 0xae, 0x3e, 0xa2,
	0x9c, 0x88, 0x14, 0xac, 0x07, 0x00, 0x5d, 0x17, 0x9f, 0x10, 0x87, 0xe0, 0xa1, 0x8f, 0x2c, 0x28,
	0x75, 0x09, 0x1b, 0x12, 0xcf, 0xd0, 0x56, 0xb4, 0x46, 0x65, 0x03, 0x6c, 0x45, 0xb1, 0x5f, 0x76,
	0x9e, 0x39, 0x31, 0x62, 0x6d, 0x42, 0x4d, 0x31, 0x9a, 0x83, 0x01, 0x99, 0x48, 0x32, 0xcc, 0x45,
	0xda, 0x8b, 0x49, 0x0e, 0x79, 0x4d, 0x06, 0x39, 0x49, 0x68, 0x09, 0x4a, 0x0e, 0xc1, 0x82, 0x33,
	0x63, 0x66, 0x45, 0x6b, 0xcc, 0x3b, 0x71, 0xa4, 0x3a, 0x90, 0xd8, 0x93, 0xfb, 0x1c, 0x0f, 0x7b,
	0x44, 0xc8, 0x5c, 0x1d, 0x6c, 0xc1, 0x42, 0x52, 0x7f, 0x18, 0x26, 0xde, 0xe2, 0x7c, 0xe3, 0xbe,
	0x80, 0xea, 0x01, 0x16, 0x92, 0x78, 0xbb, 0x98, 0xba, 0xbf, 0xd9, 0x78, 0x07, 0x2a, 0xca, 0x85,
	0x3f, 0x20, 0xf5, 0x2a, 0x96, 0x3a, 0x9c, 0x0c, 0xb1, 0x24, 0xb9, 0xa4, 0x56, 0x61, 0xa1, 0xc3,
	0x24, 0xf1, 0xf0, 0x40, 0x52, 0xce, 0xda, 0x7c, 0xca, 0xa4, 0x12, 0xd5, 0x9d, 0x1b, 0x79, 0xab,
	0x1f, 0xef, 0x6b, 0x97, 0x32, 0x2a, 0x8e, 0x72, 0xf6, 0xba, 0x06, 0xc5, 0xae, 0xc4, 0x52, 0x28,
	0xd5, 0xca, 0xc6, 0xb2, 0x9d, 0x5c, 0xa7, 0xdd, 0xe6, 0xe3, 0x3e, 0x65, 0x64, 0xa8, 0x60, 0x27,
	0xaa, 0xb2, 0x9e, 0xc0, 0x72, 0xfb, 0x88, 0x0c, 0x8e, 0x9b, 0xae, 0xab, 0xde, 0x12, 0x6d, 0xce,
	0x58, 0xee, 0xeb, 0xb0, 0x56, 0x61, 0x76, 0x8f, 0xba, 0x6e, 0xae, 0xda, 0x4f, 0x33, 0x50, 0xcb,
	0xf4, 0x80, 0xfe, 0x87, 0x5a, 0x8f, 0x4b, 0xec, 0x86, 0xf7, 0xd0, 0xa3, 0x63, 0xa2, 0xc8, 0xba,
	0x93, 0x4d, 0xa2, 0x6d, 0xa8, 0xa6, 0xac, 0x49, 0x06, 0x5b, 0xba, 0x1e, 0xac, 0x3b, 0x1d, 0x8f,
	0xb1, 0xe7, 0x47, 0x73, 0x65, 0x6a, 0x51, 0x13, 0xca, 0x0e, 0x79, 0x33, 0x25, 0x42, 0x0a, 0x43,
	0x5f, 0xd1, 0x1b, 0x95, 0x8d, 0x7b, 0xbf, 0x30, 0xc4, 0x4e, 0xea, 0x76, 0x98, 0xf4, 0x7c, 0xe7,
	0x8a, 0x56, 0xef, 0x42, 0x2d, 0x03, 0xa1, 0x05, 0xd0, 0x8f, 0x89, 0xaf, 0x7a, 0x9d, 0x77, 0xc2,
	0x4f, 0x74, 0x1f, 0x8a, 0x27, 0xd8, 0x9d, 0x92, 0x3b, 0x5a, 0x8b, 0x8a, 0xb6, 0x67, 0x1e, 0x69,
	0xd6, 0x47, 0x1d, 0xaa, 0x69, 0x0c, 0x2d, 0x42, 0x31, 0x3a, 0x86, 0xc8, 0x82, 0x28, 0x08, 0x0f,
	0x6f, 0xc7, 0xf3, 0xb8, 0x27, 0xe2, 0x1b, 0x89, 0x23, 0xf4, 0x2f, 0xcc, 0x47, 0x1e, 0x85, 0xa6,
	0xe9, 0x0a, 0xba, 0x4e, 0x20, 0x03, 0xe6, 0x0e, 0x28, 0x53, 0xd8, 0xac, 0xc2, 0x92, 0x50, 0x21,
	0xf8, 0x9d, 0x42, 0x8a, 0x31, 0x12, 0x85, 0xc8, 0x82, 0xaa, 0x12, 0x68, 0xbb, 0x94, 0x30, 0x29,
	0x8c, 0x92, 0x82, 0x33, 0x39, 0xb4, 0x0f, 0xd5, 0xe8, 0xfd, 0x96, 0xdf, 0xf3, 0x27, 0xc4, 0x98,
	0x53, 0x86, 0x36, 0x6e, 0x9f, 0xd6, 0x4e, 0x97, 0x46, 0x9e, 0x66, 0xd8, 0x68, 0x27, 0xf4, 0x55,
	0x4c, 0x38, 0x13, 0x24, 0xec, 0x40, 0x18, 0x65, 0x65, 0xde, 0x7f, 0xd7, 0x72, 0x69, 0xf8, 0x39,
	0x15, 0x92, 0x8f, 0x3c, 0x3c, 0x76, 0xb2, 0xac, 0xfa, 0x53, 0xf8, 0xfb, 0xc6, 0x4b, 0xb7, 0xac,
	0x68, 0x31, 0xbd, 0x22, 0x3d, 0xbd, 0x8a, 0x1f, 0x1a, 0xfc, 0x73, 0xeb, 0x4b, 0xa1, 0x5b, 0x61,
	0x82, 0x4f, 0x93, 0xad, 0x24, 0x61, 0x88, 0xb4, 0x28, 0xeb, 0xd2, 0xf7, 0x89, 0x5e, 0x12, 0xa2,
	0x3a, 0x94, 0x5b, 0x34, 0xfe, 0x5d, 0x47, 0x8b, 0xb9, 0x8a, 0x51, 0x07, 0xca, 0xa1, 0x40, 0x8b,
	0x32, 0x61, 0xcc, 0x2a, 0xef, 0xd6, 0xee, 0x18, 0xd6, 0x4e, 0xea, 0xe3, 0xa3, 0x4c, 0xc2, 0xfa,
	0x63, 0xa8, 0x65, 0xa0, 0xf4, 0xc4, 0xfa, 0x1d, 0x13, 0xb7, 0x1e, 0x9e, 0x9e, 0x9b, 0x85, 0xb3,
	0x73, 0xb3, 0x70, 0x79, 0x6e, 0x6a, 0x1f, 0x02, 0x53, 0xfb, 0x12, 0x98, 0xda, 0xd7, 0xc0, 0xd4,
	0x4e, 0x03, 0x53, 0xfb, 0x16, 0x98, 0xda, 0xf7, 0xc0, 0x2c, 0x5c, 0x06, 0xa6, 0xf6, 0xf9, 0xc2,
	0x2c, 0x9c, 0x5e, 0x98, 0x85, 0xb3, 0x0b, 0xb3, 0xd0, 0x2f, 0xa9, 0xff, 0xaa, 0xcd, 0x9f, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x06, 0xa5, 0x23, 0x1a, 0xff, 0x06, 0x00, 0x00,
}

func (this *SlaveReady) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveReady)
	if !ok {
		that2, ok := that.(SlaveReady)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *SlaveAccepted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveAccepted)
	if !ok {
		that2, ok := that.(SlaveAccepted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *SlaveRejected) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveRejected)
	if !ok {
		that2, ok := that.(SlaveRejected)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *StartLoadTest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartLoadTest)
	if !ok {
		that2, ok := that.(StartLoadTest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *LoadTestUnderway) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadTestUnderway)
	if !ok {
		that2, ok := that.(LoadTestUnderway)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *MasterFailed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MasterFailed)
	if !ok {
		that2, ok := that.(MasterFailed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *SlaveFailed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveFailed)
	if !ok {
		that2, ok := that.(SlaveFailed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *SlaveUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveUpdate)
	if !ok {
		that2, ok := that.(SlaveUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if this.InteractionCount != that1.InteractionCount {
		return false
	}
	return true
}
func (this *SlaveFinished) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlaveFinished)
	if !ok {
		that2, ok := that.(SlaveFinished)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if !this.Stats.Equal(that1.Stats) {
		return false
	}
	return true
}
func (this *CheckAllSlavesConnected) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckAllSlavesConnected)
	if !ok {
		that2, ok := that.(CheckAllSlavesConnected)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *Kill) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kill)
	if !ok {
		that2, ok := that.(Kill)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	return true
}
func (this *CombinedStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CombinedStats)
	if !ok {
		that2, ok := that.(CombinedStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalTestTime != that1.TotalTestTime {
		return false
	}
	if !this.Interactions.Equal(that1.Interactions) {
		return false
	}
	if len(this.Requests) != len(that1.Requests) {
		return false
	}
	for i := range this.Requests {
		if !this.Requests[i].Equal(that1.Requests[i]) {
			return false
		}
	}
	return true
}
func (this *SummaryStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SummaryStats)
	if !ok {
		that2, ok := that.(SummaryStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if this.Errors != that1.Errors {
		return false
	}
	if this.TotalTime != that1.TotalTime {
		return false
	}
	if this.MinTime != that1.MinTime {
		return false
	}
	if this.MaxTime != that1.MaxTime {
		return false
	}
	if this.TotalClients != that1.TotalClients {
		return false
	}
	if len(this.ErrorsByType) != len(that1.ErrorsByType) {
		return false
	}
	for i := range this.ErrorsByType {
		if this.ErrorsByType[i] != that1.ErrorsByType[i] {
			return false
		}
	}
	if !this.ResponseTimes.Equal(that1.ResponseTimes) {
		return false
	}
	return true
}
func (this *ResponseTimeHistogram) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseTimeHistogram)
	if !ok {
		that2, ok := that.(ResponseTimeHistogram)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.BinSize != that1.BinSize {
		return false
	}
	if this.BinCount != that1.BinCount {
		return false
	}
	if len(this.TimeBins) != len(that1.TimeBins) {
		return false
	}
	for i := range this.TimeBins {
		if this.TimeBins[i] != that1.TimeBins[i] {
			return false
		}
	}
	return true
}
func (this *SlaveReady) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SlaveReady{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SlaveAccepted) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SlaveAccepted{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SlaveRejected) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SlaveRejected{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StartLoadTest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.StartLoadTest{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadTestUnderway) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.LoadTestUnderway{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MasterFailed) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.MasterFailed{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SlaveFailed) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SlaveFailed{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SlaveUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SlaveUpdate{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "InteractionCount: "+fmt.Sprintf("%#v", this.InteractionCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SlaveFinished) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.SlaveFinished{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	if this.Stats != nil {
		s = append(s, "Stats: "+fmt.Sprintf("%#v", this.Stats)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CheckAllSlavesConnected) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.CheckAllSlavesConnected{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Kill) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.Kill{")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CombinedStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.CombinedStats{")
	s = append(s, "TotalTestTime: "+fmt.Sprintf("%#v", this.TotalTestTime)+",\n")
	if this.Interactions != nil {
		s = append(s, "Interactions: "+fmt.Sprintf("%#v", this.Interactions)+",\n")
	}
	keysForRequests := make([]string, 0, len(this.Requests))
	for k, _ := range this.Requests {
		keysForRequests = append(keysForRequests, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRequests)
	mapStringForRequests := "map[string]*SummaryStats{"
	for _, k := range keysForRequests {
		mapStringForRequests += fmt.Sprintf("%#v: %#v,", k, this.Requests[k])
	}
	mapStringForRequests += "}"
	if this.Requests != nil {
		s = append(s, "Requests: "+mapStringForRequests+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SummaryStats) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&messages.SummaryStats{")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	s = append(s, "Errors: "+fmt.Sprintf("%#v", this.Errors)+",\n")
	s = append(s, "TotalTime: "+fmt.Sprintf("%#v", this.TotalTime)+",\n")
	s = append(s, "MinTime: "+fmt.Sprintf("%#v", this.MinTime)+",\n")
	s = append(s, "MaxTime: "+fmt.Sprintf("%#v", this.MaxTime)+",\n")
	s = append(s, "TotalClients: "+fmt.Sprintf("%#v", this.TotalClients)+",\n")
	keysForErrorsByType := make([]string, 0, len(this.ErrorsByType))
	for k, _ := range this.ErrorsByType {
		keysForErrorsByType = append(keysForErrorsByType, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForErrorsByType)
	mapStringForErrorsByType := "map[string]int64{"
	for _, k := range keysForErrorsByType {
		mapStringForErrorsByType += fmt.Sprintf("%#v: %#v,", k, this.ErrorsByType[k])
	}
	mapStringForErrorsByType += "}"
	if this.ErrorsByType != nil {
		s = append(s, "ErrorsByType: "+mapStringForErrorsByType+",\n")
	}
	if this.ResponseTimes != nil {
		s = append(s, "ResponseTimes: "+fmt.Sprintf("%#v", this.ResponseTimes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseTimeHistogram) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.ResponseTimeHistogram{")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "BinSize: "+fmt.Sprintf("%#v", this.BinSize)+",\n")
	s = append(s, "BinCount: "+fmt.Sprintf("%#v", this.BinCount)+",\n")
	keysForTimeBins := make([]int64, 0, len(this.TimeBins))
	for k, _ := range this.TimeBins {
		keysForTimeBins = append(keysForTimeBins, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTimeBins)
	mapStringForTimeBins := "map[int64]int64{"
	for _, k := range keysForTimeBins {
		mapStringForTimeBins += fmt.Sprintf("%#v: %#v,", k, this.TimeBins[k])
	}
	mapStringForTimeBins += "}"
	if this.TimeBins != nil {
		s = append(s, "TimeBins: "+mapStringForTimeBins+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringLoadtest(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SlaveReady) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveReady) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n1, err1 := m.Sender.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *SlaveAccepted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveAccepted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n2, err2 := m.Sender.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *SlaveRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveRejected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n3, err3 := m.Sender.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *StartLoadTest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartLoadTest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n4, err4 := m.Sender.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}

func (m *LoadTestUnderway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadTestUnderway) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n5, err5 := m.Sender.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *MasterFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MasterFailed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n6, err6 := m.Sender.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *SlaveFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveFailed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n7, err7 := m.Sender.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *SlaveUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n8, err8 := m.Sender.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.InteractionCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.InteractionCount))
	}
	return i, nil
}

func (m *SlaveFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlaveFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n9, err9 := m.Sender.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.Stats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Stats.Size()))
		n10, err10 := m.Stats.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}

func (m *CheckAllSlavesConnected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckAllSlavesConnected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n11, err11 := m.Sender.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}

func (m *Kill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Sender.Size()))
		n12, err12 := m.Sender.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}

func (m *CombinedStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CombinedStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalTestTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.TotalTestTime))
	}
	if m.Interactions != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Interactions.Size()))
		n13, err13 := m.Interactions.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			dAtA[i] = 0x1a
			i++
			v := m.Requests[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovLoadtest(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovLoadtest(uint64(len(k))) + msgSize
			i = encodeVarintLoadtest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLoadtest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintLoadtest(dAtA, i, uint64(v.Size()))
				n14, err14 := v.MarshalTo(dAtA[i:])
				if err14 != nil {
					return 0, err14
				}
				i += n14
			}
		}
	}
	return i, nil
}

func (m *SummaryStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummaryStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Count))
	}
	if m.Errors != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Errors))
	}
	if m.TotalTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.TotalTime))
	}
	if m.MinTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.MinTime))
	}
	if m.MaxTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.MaxTime))
	}
	if m.TotalClients != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.TotalClients))
	}
	if len(m.ErrorsByType) > 0 {
		for k, _ := range m.ErrorsByType {
			dAtA[i] = 0x3a
			i++
			v := m.ErrorsByType[k]
			mapSize := 1 + len(k) + sovLoadtest(uint64(len(k))) + 1 + sovLoadtest(uint64(v))
			i = encodeVarintLoadtest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLoadtest(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintLoadtest(dAtA, i, uint64(v))
		}
	}
	if m.ResponseTimes != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.ResponseTimes.Size()))
		n15, err15 := m.ResponseTimes.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	return i, nil
}

func (m *ResponseTimeHistogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseTimeHistogram) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.Timeout))
	}
	if m.BinSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.BinSize))
	}
	if m.BinCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLoadtest(dAtA, i, uint64(m.BinCount))
	}
	if len(m.TimeBins) > 0 {
		for k, _ := range m.TimeBins {
			dAtA[i] = 0x22
			i++
			v := m.TimeBins[k]
			mapSize := 1 + sovLoadtest(uint64(k)) + 1 + sovLoadtest(uint64(v))
			i = encodeVarintLoadtest(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintLoadtest(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintLoadtest(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeVarintLoadtest(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SlaveReady) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *SlaveAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *SlaveRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *StartLoadTest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *LoadTestUnderway) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *MasterFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *SlaveFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *SlaveUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	if m.InteractionCount != 0 {
		n += 1 + sovLoadtest(uint64(m.InteractionCount))
	}
	return n
}

func (m *SlaveFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *CheckAllSlavesConnected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *Kill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *CombinedStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalTestTime != 0 {
		n += 1 + sovLoadtest(uint64(m.TotalTestTime))
	}
	if m.Interactions != nil {
		l = m.Interactions.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovLoadtest(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovLoadtest(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovLoadtest(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SummaryStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovLoadtest(uint64(m.Count))
	}
	if m.Errors != 0 {
		n += 1 + sovLoadtest(uint64(m.Errors))
	}
	if m.TotalTime != 0 {
		n += 1 + sovLoadtest(uint64(m.TotalTime))
	}
	if m.MinTime != 0 {
		n += 1 + sovLoadtest(uint64(m.MinTime))
	}
	if m.MaxTime != 0 {
		n += 1 + sovLoadtest(uint64(m.MaxTime))
	}
	if m.TotalClients != 0 {
		n += 1 + sovLoadtest(uint64(m.TotalClients))
	}
	if len(m.ErrorsByType) > 0 {
		for k, v := range m.ErrorsByType {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLoadtest(uint64(len(k))) + 1 + sovLoadtest(uint64(v))
			n += mapEntrySize + 1 + sovLoadtest(uint64(mapEntrySize))
		}
	}
	if m.ResponseTimes != nil {
		l = m.ResponseTimes.Size()
		n += 1 + l + sovLoadtest(uint64(l))
	}
	return n
}

func (m *ResponseTimeHistogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timeout != 0 {
		n += 1 + sovLoadtest(uint64(m.Timeout))
	}
	if m.BinSize != 0 {
		n += 1 + sovLoadtest(uint64(m.BinSize))
	}
	if m.BinCount != 0 {
		n += 1 + sovLoadtest(uint64(m.BinCount))
	}
	if len(m.TimeBins) > 0 {
		for k, v := range m.TimeBins {
			_ = k
			_ = v
			mapEntrySize := 1 + sovLoadtest(uint64(k)) + 1 + sovLoadtest(uint64(v))
			n += mapEntrySize + 1 + sovLoadtest(uint64(mapEntrySize))
		}
	}
	return n
}

func sovLoadtest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLoadtest(x uint64) (n int) {
	return sovLoadtest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SlaveReady) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveReady{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlaveAccepted) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveAccepted{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlaveRejected) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveRejected{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StartLoadTest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StartLoadTest{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadTestUnderway) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadTestUnderway{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MasterFailed) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MasterFailed{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlaveFailed) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveFailed{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlaveUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveUpdate{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`InteractionCount:` + fmt.Sprintf("%v", this.InteractionCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SlaveFinished) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SlaveFinished{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`Stats:` + strings.Replace(this.Stats.String(), "CombinedStats", "CombinedStats", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CheckAllSlavesConnected) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CheckAllSlavesConnected{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Kill) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Kill{`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "PID", "actor.PID", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CombinedStats) String() string {
	if this == nil {
		return "nil"
	}
	keysForRequests := make([]string, 0, len(this.Requests))
	for k, _ := range this.Requests {
		keysForRequests = append(keysForRequests, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRequests)
	mapStringForRequests := "map[string]*SummaryStats{"
	for _, k := range keysForRequests {
		mapStringForRequests += fmt.Sprintf("%v: %v,", k, this.Requests[k])
	}
	mapStringForRequests += "}"
	s := strings.Join([]string{`&CombinedStats{`,
		`TotalTestTime:` + fmt.Sprintf("%v", this.TotalTestTime) + `,`,
		`Interactions:` + strings.Replace(this.Interactions.String(), "SummaryStats", "SummaryStats", 1) + `,`,
		`Requests:` + mapStringForRequests + `,`,
		`}`,
	}, "")
	return s
}
func (this *SummaryStats) String() string {
	if this == nil {
		return "nil"
	}
	keysForErrorsByType := make([]string, 0, len(this.ErrorsByType))
	for k, _ := range this.ErrorsByType {
		keysForErrorsByType = append(keysForErrorsByType, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForErrorsByType)
	mapStringForErrorsByType := "map[string]int64{"
	for _, k := range keysForErrorsByType {
		mapStringForErrorsByType += fmt.Sprintf("%v: %v,", k, this.ErrorsByType[k])
	}
	mapStringForErrorsByType += "}"
	s := strings.Join([]string{`&SummaryStats{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`Errors:` + fmt.Sprintf("%v", this.Errors) + `,`,
		`TotalTime:` + fmt.Sprintf("%v", this.TotalTime) + `,`,
		`MinTime:` + fmt.Sprintf("%v", this.MinTime) + `,`,
		`MaxTime:` + fmt.Sprintf("%v", this.MaxTime) + `,`,
		`TotalClients:` + fmt.Sprintf("%v", this.TotalClients) + `,`,
		`ErrorsByType:` + mapStringForErrorsByType + `,`,
		`ResponseTimes:` + strings.Replace(this.ResponseTimes.String(), "ResponseTimeHistogram", "ResponseTimeHistogram", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseTimeHistogram) String() string {
	if this == nil {
		return "nil"
	}
	keysForTimeBins := make([]int64, 0, len(this.TimeBins))
	for k, _ := range this.TimeBins {
		keysForTimeBins = append(keysForTimeBins, k)
	}
	github_com_gogo_protobuf_sortkeys.Int64s(keysForTimeBins)
	mapStringForTimeBins := "map[int64]int64{"
	for _, k := range keysForTimeBins {
		mapStringForTimeBins += fmt.Sprintf("%v: %v,", k, this.TimeBins[k])
	}
	mapStringForTimeBins += "}"
	s := strings.Join([]string{`&ResponseTimeHistogram{`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`BinSize:` + fmt.Sprintf("%v", this.BinSize) + `,`,
		`BinCount:` + fmt.Sprintf("%v", this.BinCount) + `,`,
		`TimeBins:` + mapStringForTimeBins + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLoadtest(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SlaveReady) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveReady: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveReady: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlaveAccepted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveAccepted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveAccepted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlaveRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartLoadTest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartLoadTest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartLoadTest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadTestUnderway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadTestUnderway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadTestUnderway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MasterFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MasterFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MasterFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlaveFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlaveUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractionCount", wireType)
			}
			m.InteractionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InteractionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlaveFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlaveFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlaveFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &CombinedStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckAllSlavesConnected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckAllSlavesConnected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckAllSlavesConnected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &actor.PID{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinedStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinedStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinedStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTestTime", wireType)
			}
			m.TotalTestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTestTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interactions == nil {
				m.Interactions = &SummaryStats{}
			}
			if err := m.Interactions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requests == nil {
				m.Requests = make(map[string]*SummaryStats)
			}
			var mapkey string
			var mapvalue *SummaryStats
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLoadtest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLoadtest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLoadtest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthLoadtest
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthLoadtest
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SummaryStats{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLoadtest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLoadtest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummaryStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummaryStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummaryStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			m.Errors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errors |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTime", wireType)
			}
			m.TotalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTime", wireType)
			}
			m.MinTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			m.MaxTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalClients", wireType)
			}
			m.TotalClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalClients |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorsByType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ErrorsByType == nil {
				m.ErrorsByType = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLoadtest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLoadtest
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthLoadtest
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLoadtest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLoadtest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ErrorsByType[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTimes == nil {
				m.ResponseTimes = &ResponseTimeHistogram{}
			}
			if err := m.ResponseTimes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseTimeHistogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseTimeHistogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseTimeHistogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinSize", wireType)
			}
			m.BinSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinCount", wireType)
			}
			m.BinCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeBins", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLoadtest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLoadtest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeBins == nil {
				m.TimeBins = make(map[int64]int64)
			}
			var mapkey int64
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLoadtest
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLoadtest
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLoadtest(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLoadtest
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TimeBins[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLoadtest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLoadtest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLoadtest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLoadtest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLoadtest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLoadtest
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLoadtest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLoadtest
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLoadtest(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLoadtest
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLoadtest = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLoadtest   = fmt.Errorf("proto: integer overflow")
)
