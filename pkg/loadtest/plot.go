package loadtest

import (
	"encoding/csv"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"
)

var desiredPrometheusMetrics = map[string]interface{}{
	"go_goroutines":                               nil,
	"go_memstats_alloc_bytes":                     nil,
	"go_threads":                                  nil,
	"node_memory_MemFree_bytes":                   nil,
	"node_network_receive_bytes_total":            nil,
	"node_network_transmit_bytes_total":           nil,
	"node_procs_running":                          nil,
	"process_open_fds":                            nil,
	"tendermint_consensus_block_interval_seconds": nil,
	"tendermint_consensus_block_size_bytes":       nil,
	"tendermint_consensus_byzantine_validators":   nil,
	"tendermint_consensus_height":                 nil,
	"tendermint_consensus_latest_block_height":    nil,
	"tendermint_consensus_num_txs":                nil,
	"tendermint_consensus_rounds":                 nil,
	"tendermint_consensus_total_txs":              nil,
	"tendermint_mempool_size":                     nil,
	"tendermint_p2p_peer_receive_bytes_total":     nil,
	"tendermint_p2p_peer_send_bytes_total":        nil,
	"tendermint_p2p_peers":                        nil,
}

// PlotSingleTestSummaryResults will look in the given `inputDir` for a
// `summary.csv` file (generated by the single-test load testing) and write the
// relevant plotly.js files out to the given `outputDir` (one for each
// histogram, basically).
func PlotSingleTestSummaryResults(inputDir, outputDir string) error {
	// ensure the output path exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("Failed to create output directory %s: %s", outputDir, err.Error())
	}
	summaryStatsFile := path.Join(inputDir, "summary.csv")
	stats, err := ReadCombinedStatsFromFile(summaryStatsFile)
	if err != nil {
		return fmt.Errorf("Failed to read combined stats from file %s: %s", summaryStatsFile, err.Error())
	}
	cfgFile := path.Join(inputDir, "config.toml")
	cfg, err := LoadConfig(cfgFile)
	if err != nil {
		return fmt.Errorf("Failed to load configuration from file %s: %s", cfgFile, err.Error())
	}
	nodesStats, err := readPrometheusStats(cfg, inputDir)
	if err != nil {
		return err
	}
	result, err := RenderSingleTestSummaryPlot(cfg, stats, nodesStats)
	if err != nil {
		return fmt.Errorf("Failed to render summary plot: %s", err.Error())
	}
	outputFile := path.Join(outputDir, "single-test-summary.html")
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("Failed to create output file %s: %s", outputFile, err.Error())
	}
	defer f.Close()
	if _, err := f.Write([]byte(result)); err != nil {
		return fmt.Errorf("Failed to write output template to %s: %s", outputFile, err.Error())
	}
	return nil
}

func readPrometheusStats(cfg *Config, inputDir string) (map[string]map[string]MetricFamilyData, error) {
	var emptyMap map[string]map[string]MetricFamilyData

	// metric family ID -> hostname -> metric family data
	nodesStats := make(map[string]map[string]MetricFamilyData)
	timestamps := make([]float64, 0)

	for _, target := range cfg.TestNetwork.Targets {
		ferr := func() error {
			hostStatsFile := path.Join(inputDir, fmt.Sprintf("%s.csv", target.ID))
			f, err := os.Open(hostStatsFile)
			if err != nil {
				return fmt.Errorf("Failed to open host stats file for reading: %s", hostStatsFile)
			}
			defer f.Close()

			// read the timestamps from the file
			cr := csv.NewReader(f)
			row, err := cr.Read()
			if err != nil {
				return fmt.Errorf("Failed to read first row of CSV file: %s (%s)", hostStatsFile, err)
			}

			if len(row) < 3 {
				return fmt.Errorf("Not enough timestamps in host stats file: %s", hostStatsFile)
			}

			hostTimestamps := make([]float64, 0)
			// parse out the timestamps
			for i, ts := range row[2:] {
				tsf, err := strconv.ParseFloat(ts, 64)
				if err != nil {
					return fmt.Errorf("Failed to parse timestamp in row 0, column %d (%s) of %s", 2+i, ts, hostStatsFile)
				}
				hostTimestamps = append(hostTimestamps, tsf)
			}
			if len(timestamps) == 0 {
				timestamps = hostTimestamps
			} else {
				if len(timestamps) != len(hostTimestamps) {
					return fmt.Errorf("Timestamps for host stats file %s do not match first host's timestamps", hostStatsFile)
				}
			}

			lineNo := 1
			// now parse out the metric families we want
			for {
				row, err = cr.Read()
				if err != nil {
					break
				}
				mfIDParts := strings.Split(row[0], ":")
				mfID := mfIDParts[0]
				if len(mfIDParts) > 1 {
					mfID = strings.Join(mfIDParts[1:], ":")
				}

				if _, mfDesired := desiredPrometheusMetrics[mfID]; mfDesired {
					if len(row)-2 < len(timestamps) {
						return fmt.Errorf("Not enough data in host stats file (expected %d entries, but got %d), line %d: %s", len(timestamps), len(row)-2, lineNo, hostStatsFile)
					}

					values := make([]float64, 0)
					for i, val := range row[2:] {
						valf, err := strconv.ParseFloat(val, 64)
						if err != nil {
							return fmt.Errorf("Failed to parse data point in row %d, column %d (%s) of %s", lineNo, 2+i, val, hostStatsFile)
						}
						values = append(values, valf)
					}
					mfData := MetricFamilyData{
						ID:         row[0],
						Help:       row[1],
						Data:       values,
						Timestamps: timestamps,
					}
					if _, ok := nodesStats[mfData.ID]; !ok {
						nodesStats[mfData.ID] = make(map[string]MetricFamilyData)
					}
					nodesStats[mfData.ID][target.ID] = mfData
				}

				lineNo++
			}

			return nil
		}()
		if ferr != nil {
			return emptyMap, ferr
		}
	}

	return nodesStats, nil
}
